<!DOCTYPE html>
<html lang="en"> 
	<head>
	<title>blog</title>
	<link rel="stylesheet" href="style.css">

	</head>
	
		<h1 id ="centre"><b>blog</b></h1>
        <a href="/"><p style="text-align: center; color:black; font-family:courier; font-size: 100%;">>home</p></a>
        <p style="text-align: center; color:black; font-family:courier; font-size: 100%;">im making this to keep track of wth im doing</p>


        <div id="blog-container">

         
          
                <div class="blog-post">
                    <a href="https://github.com/lkishawi3/DoomEngine"><h2>Doom Engine</h2></a>
                    
                    <p><b>Version 0.1</b></p>
                    <p>Date: July 11, 2023</p>
                    <div class ="short-content">
                        <p>I made a simple version of doom in java a few days ago, I only got up to making simple raytracing to render and walk around a map array. I found a project made by a leonardo-ono of a Wolfenstein 3D game engine in java that uses the original game files to load the game.<a href="https://github.com/leonardo-ono/JavaWolf3DGameEngine"><p style="color:black; font-family:courier;">>github JavaWolf3DGameEngine </p></a> So I decided to work on a similar project, A Doom engine in java that runs from the original wad file. This is a big project so to start I want to outline the main parts. <br><br> 1. Understand the WAD file format <br> 2. Create WAD file loader <br> 3. Understand and Implement the Doom rendering engine <br> 4. Add game physics <br> 5. Add sound and other features <br> <br>So what is a WAD file? WAD stands for Where's All the Data? It...</p>
                    </div>
                    <div class="full-content">
                    <p>I made a simple version of doom in java a few days ago, I only got up to making simple raytracing to render and walk around a map array. I found a project made by a leonardo-ono of a Wolfenstein 3D game engine in java that uses the original game files to load the game.<a href="https://github.com/leonardo-ono/JavaWolf3DGameEngine"><p style="color:black; font-family:courier;">>github JavaWolf3DGameEngine </p></a> So I decided to work on a similar project, A Doom engine in java that runs from the original wad file. This is a big project so to start I want to outline the main parts. <br><br> 1. Understand the WAD file format <br> 2. Create WAD file loader <br> 3. Understand and Implement the Doom rendering engine <br> 4. Add game physics <br> 5. Add sound and other features <br> <br>So what is a WAD file? WAD stands for Where's All the Data? It is the default data file used by the Doom engine, IWADs contain all the original game data e.g, DOOM1.WAD. PWADs are Patch files to modify or add to the original game, they can contain levels, graphics or sound effects; PWADs are often player created content. <br> <br> What is inside a WAD?<br> WAD files contain lumps; lumps are individual data entries that contain the game content, each lump is a block of data: <br> <br>1. Levels: THINGS(object placements), LINEDEFS(walls and special effects), SIDEDEFS(wall textures), VERTEXES(shape of map), SEGS, SSECTORS, NODES(visibility data), SECTORS(floors and ceilings), REJECT(monster AI data), BLOCKMAP(collision data). <br> 2. Sprites: TROOA1, SAAGA1(monster). <br> 3. Textures: TEXTURE1(walltextures), F_START(floor & ceiling). <br> 4. Palette: PLAYPAL(color table). <br> 5. Colormap: COLORMAP(lighting). <br> Music and sound effects are saved in unique lump names. <br> <br> To start making our engine we have to be able to read from the wad file, the first class I created was WadFile.java, inside I create a WadFile object that represents DOOM1.WAD. <br><br><code> WadFile wadFile = new WadFile("src/DOOM1.WAD"); </code> <br> <br> When DOOM1.WAD is opened it reads the header and creates a WadDirectoryEntry for each entry in the directory, lets have a look at them. <br> <br><code>for (WadDirectoryEntry entry : wadFile.getDirectory()) {<br><span style="display: inline-block; margin-left: 40px;"></span>System.out.println(entry.getName()); <br>} </code>  <br>  <div id ="image-container"><img src="/wadfileoutput.png" width="70%" height="70%" alt="WAD File Output"></div> <br> Now we have the WAD file loaded and lumps in a list, notice E1M1 this is <br>Episode 1, Mission 1 the first Level.<br> <br> The next thing I did was try to load a sprite to do this we need to decode the lump data, TROOA1 is a sprite for imp monster. <br><br><code>public class Main { <br>  <span style="display: inline-block; margin-left: 40px;">public static void main(String[] args) { </span><br><span style="display: inline-block; margin-left: 80px;"> try { </span><br> <span style="display: inline-block; margin-left: 120px;"></span>WadFile wadFile = new WadFile("src/DOOM1.WAD"); <br> <span style="display: inline-block; margin-left: 120px;"></span>byte[] spriteData = null; <br> <span style="display: inline-block; margin-left: 120px;"></span>for (WadDirectoryEntry entry : wadFile.getDirectory()) { <br> <span style="display: inline-block; margin-left: 150px;"></span>if (entry.getName().equals("TROOA1")) { <br> <span style="display: inline-block; margin-left: 40px;"></span> <span style="display: inline-block; margin-left: 140px;"></span>spriteData = wadFile.getLumpData(entry); <br> <span style="display: inline-block; margin-left: 190px;"></span>break; <br> <span style="display: inline-block; margin-left: 140px;"></span>} <br> <span style="display: inline-block; margin-left: 80px;"></span>} <br> <span style="display: inline-block; margin-left: 80px;"></span>if (spriteData != null) { <br> <span style="display: inline-block; margin-left: 100px;"></span>//decode sprite data <br><span style="display: inline-block; margin-left: 80px;"></span>} else { <br><span style="display: inline-block; margin-left: 100px;"></span>System.out.println("Could not find TROOA1 lump."); <br><span style="display: inline-block; margin-left: 80px;"></span>} <br><span style="display: inline-block; margin-left: 40px;"></span>} catch (IOException e) { <br><span style="display: inline-block; margin-left: 100px;"></span>e.printStackTrace(); <br><span style="display: inline-block; margin-left: 60px;"></span> } <br> <span style="display: inline-block; margin-left: 35px;"></span>} <br> }</code> <br> <br> This loops over the directory entires until it finds the name TROOA1. Now we have to retrive the data from this lump, we'll add this to WadFile <br> <br> <code>public byte[] getLumpData(WadDirectoryEntry entry) { <br> <span style="display: inline-block; margin-left: 40px;"></span>int index = directory.indexOf(entry); <br> <span style="display: inline-block; margin-left: 40px;"></span>if (index != -1) { <br> <span style="display: inline-block; margin-left: 80px;"></span> return lumps.get(index); <br> <span style="display: inline-block; margin-left: 40px;">} else { </span><br> <span style="display: inline-block; margin-left: 80px;">return null;</span><br><span style="display: inline-block; margin-left: 40px;">}</span><br>}</code> <br><br> This gets the lump data from WadDirectoryEntry and saves it as a byte array in spriteData. <br> <br> Next we need to decode this data, todo this we need to understand how the WAD file stores it's data. <br> This is the sprite's structure: <br> <br> Offset 0-1: Sprite width <br> Offset 2-3: Sprite height <br> Offset 4-5: Sprite left offset <br> Offset 6-7: Sprite top offset <br> Offset 8+: Column directory <br> <br> The column directory is a grid for each pixel, each column of pixels is called a post. The column directory is a list of offsets/pointers to these posts, by following each offset in the column directory, we can find and decode each post to reconstruct the image. <br> Each post has this structure: <br> <br> Start Byte: Starting row for post. <br> Length byte: Number of pixels in post. <br> Padding byte: Always 0. <br> Pixel data: one byte per pixel. <br> End byte: Always 255.<br> <br> Decoding the sprite data.<br> Java doesn't have unsigned bytes, a byte in java is signed and has a range from -128 to 127. The pixel data in the spite lump are unsigned bytes with a range from 0 to 255, when reading the data in java we'll need to convert the signed bytes to unsigned this can be done using the 'Byte.toUnsignedInt' method. <br> <br> <code> if (spriteData != null) { <br> <span style="display: inline-block; margin-left: 20px;"></span>int width = Byte.toUnsignedInt(spriteData[0]) | (Byte.toUnsignedInt[1]) << 8); </code> <br> <br> Do this with each variable:<br> width, height, leftOffset, topOffset <br> Then we need to decode each column, <br></p>
                    <p> <code>for (int column = 0; column < width; column++) {</code> <br> This loops through each column of the sprite<br><br> <code>   <span style="display: inline-block; margin-left: 100px;"></span>int columnOffset = Byte.toUnsignedInt(spriteData[8 + column * 4]) | <br> (Byte.toUnsignedInt(spriteData[9 + column * 4]) << 8) <br> <span style="display: inline-block; margin-left: 100px;"></span>| (Byte.toUnsignedInt(spriteData[10 + column * 4]) << 16) | <br> (Byte.toUnsignedInt(spriteData[11 + column * 4]) << 24);</code> <br>Finds the offset to the column data <br><br><code>int offset = columnOffset; <br>while (Byte.toUnsignedInt(spriteData[offset]) != 255) {<br>int topdelta = Byte.toUnsignedInt(spriteData[offset++]);<br>int length = Byte.toUnsignedInt(spriteData[offset++]);<br>offset++; // Skip the padding byte</code> <br> Iterate though each post in the column <br> <br> <code>for (int i = 0; i < length; i++) {<br>spritePixels[column + (topdelta + i) * width] = <br>Byte.toUnsignedInt(spriteData[offset++]);<br>}<br>offset++; // Skip the end of post byte<br><span style="display: inline-block; margin-left: 20px;"></span>}<br>}</code><br>Read the post's data and copy to the sprite data<br><br>The next step is to convert the palette indices into RGB, first we need to get the lump PLAYPAL. use the same getDirectory method as before and add paletteData to the if statement like so. <br><code>if (spriteData != null && paletteData != null) {</code><br><br>The PLAYPAL lump is a series of 14 palettes, each containing 256 colors, the first palette is used for the main game components and the rest is for special effects.<br><br>Inside the if statement we must convert the palette to RGB<br><br> <code>for (int i = 0; i < spritePixels.length; i++) {<br><span style="display: inline-block; margin-left: 100px;"><code>int paletteIndex = spritePixels[i];<br>int red = Byte.toUnsignedInt(paletteData[paletteIndex * 3]);<br>int green = Byte.toUnsignedInt(paletteData[paletteIndex * 3 + 1]);<br>int blue = Byte.toUnsignedInt(paletteData[paletteIndex * 3 + 2]);<br>spritePixels[i] = (red << 16) | (green << 8) | blue;</code></span><br>}</code><br><br>Now all we have to do is create a window and display the image. <br>Add the necessary java libraries.<br><code>import javax.swing.*<br>import java.awt.*;</code> <br><br>Create a image from the sprite data<br><code>BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);<br>image.setRGB(0, 0, width, height, spritePixels, 0, width);</code> <br> <br> Create a window to display the image <br><code>JFrame frame = new JFrame("Doom Sprite");<br>frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);<br>JLabel label = new JLabel(new ImageIcon(image));<br>frame.getContentPane().add(label, BorderLayout.CENTER);<br>frame.pack();<br>frame.setLocationRelativeTo(null);<br>frame.setVisible(true);</code><br><br> This should now display the imp sprite in a window when run. <div id ="image-container"><img src="/ImpSprite.png" width="50%" height="50%" alt="Imp Sprite"></div> <br> <br> This is all I have done for today, for the purpose of brevity I have only included the important parts of the code, full source is on github.</p>
                </div>
                <button class="read-more-btn">>Read More</button>
                </div>

                <div class="blog-post">
                  <a href="https://github.com/lkishawi3/DoomEngine"><h2>Doom Engine</h2></a>
                  
                  <p><b>Version 0.5</b></p>
                  <p>Date: August 25, 2023</p>
                  <div class ="short-content">
                      <p>I've been working on sprite animation and rendering, since my attempts at rendering a top down view of the first level has had some problems. The first thing I did to render the level was create a new class "Level.java" to represent the doom level and retrieve the following lump. <br> <br> - Thing <br> - Linedef <br> - Vertex <br> - Sidedef <br> - Sector <br> <br> To understand the data in these lumps the Level class also parses and interprets the raw binary data from the WAD file and...</p>
                  </div>
                  <div class="full-content">
                  <p>I've been working on sprite animation and rendering, since my attempts at rendering a top down view of the first level has had some problems. The first thing I did to render the level was create a new class "Level.java" to represent the doom level and retrieve the following lump. <br> <br> - Thing <br> - Linedef <br> - Vertex <br> - Sidedef <br> - Sector <br> <br> To understand the data in these lumps the Level class also parses and interprets the raw binary data from the WAD file and converts it into usable java objects e.g.<br> <br>  <code> <span style="display: inline-block; margin-left: 20px;"></span> private List<Thing> parseThings(byte[] data) { <br>
                    List<Thing> things = new ArrayList<>(); <br>
                    for (int i = 0; i + 9 < data.length; i += 10) {<br>
                        int x = Byte.toUnsignedInt(data[i]) | <br>
                        <span style="display: inline-block; margin-left: 20px;"></span> (Byte.toUnsignedInt(data[i + 1]) << 8);<br>
                        int y = Byte.toUnsignedInt(data[i + 2]) | <br>
                        <span style="display: inline-block; margin-left: 20px;"></span> (Byte.toUnsignedInt(data[i + 3]) << 8);<br>
                        int angle = Byte.toUnsignedInt(data[i + 4]) | <br>
                        <span style="display: inline-block; margin-left: 20px;"></span> (Byte.toUnsignedInt(data[i + 5]) << 8);<br>
                        int type = Byte.toUnsignedInt(data[i + 6]) | <br>
                        <span style="display: inline-block; margin-left: 20px;"></span>  (Byte.toUnsignedInt(data[i + 7]) << 8);<br>
                        int flags = Byte.toUnsignedInt(data[i + 8]) | <br>
                        <span style="display: inline-block; margin-left: 20px;"></span> (Byte.toUnsignedInt(data[i + 9]) << 8);<br>
                        things.add(new Thing(x, y, angle, type, flags));<br>
                    }<br>
                    return things;<br>
                  }</code><br><br> Two more classes were needed, "DoomViewer.java" and "LevelComponent.java". LevelComponent extends JComponent and paints the level grid on a GUI. <br> <br> <code> protected void paintComponent(Graphics g) { <br>
                    <span style="display: inline-block; margin-left: 20px;"></span>super.paintComponent(g); <br><br>
                    <span style="display: inline-block; margin-left: 20px;"></span>int[][] grid = level.getGrid();<br>
                    <span style="display: inline-block; margin-left: 20px;"></span>for (int x = 0; x < grid.length; x++) { <br>
                    <span style="display: inline-block; margin-left: 40px;"></span>for (int y = 0; y < grid.length; y++) { <br>
                    <span style="display: inline-block; margin-left: 60px;"></span>if (grid[x][y] == 0) { <br>
                    <span style="display: inline-block; margin-left: 80px;"></span>g.setColor(Color.WHITE); <br>
                    <span style="display: inline-block; margin-left: 60px;"></span>} else if (grid[x][y] == 1) { <br>
                    <span style="display: inline-block; margin-left: 80px;"></span>g.setColor(Color.BLACK); <br>
                    <span style="display: inline-block; margin-left: 60px;"></span>} else { <br>
                    <span style="display: inline-block; margin-left: 80px;"></span>g.setColor(Color.GRAY); <br>
                    <span style="display: inline-block; margin-left: 60px;"></span>} <br><br>
                    <span style="display: inline-block; margin-left: 60px;"></span>g.fillRect(x * 5, y * 5, 5, 5); <br>
                    <span style="display: inline-block; margin-left: 40px;"></span>} <br>
                    <span style="display: inline-block; margin-left: 20px;"></span>} <br>
                  }</code><br><br> The paintComponent method uses its Graphics g object to fill rectangles on the screen for a top down view of the level.<br>DoomViewer.java is the executable that combines all the infomation, it also creates the Wadfile and Level instance.<br><br><code>public static void main(String[] args) { <br>
                    <span style="display: inline-block; margin-left: 20px;"></span>// Create a WadFile instance<br>
                    <span style="display: inline-block; margin-left: 20px;"></span>WadFile wadFile;<br>
                    <span style="display: inline-block; margin-left: 20px;"></span>try {<br>
                    <span style="display: inline-block; margin-left: 60px;"></span>wadFile = new WadFile("src/Doom1.WAD");<br>
                    <span style="display: inline-block; margin-left: 60px;"></span>System.out.println("WadFile created successfully!"); <br>
                    <span style="display: inline-block; margin-left: 60px;"></span>System.out.println("WadFile Header: " + wadFile.getHeader()); <br>
                    <span style="display: inline-block; margin-left: 20px;"></span>} catch (IOException e) { <br>
                    <span style="display: inline-block; margin-left: 60px;"></span>System.out.println("Failed to create WadFile");<br>
                    <span style="display: inline-block; margin-left: 60px;"></span>e.printStackTrace(); <br>
                    <span style="display: inline-block; margin-left: 60px;"></span>return;<br>
                    <span style="display: inline-block; margin-left: 20px;"></span>}</code><br><br> And Jframe for the window.<br><br><code>JFrame frame = new JFrame("Doom Viewer");<br>
                      frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);<br>LevelComponent levelComponent = new LevelComponent(level);<br>
                      frame.getContentPane().add(levelComponent);<br>frame.setSize(800, 600);<br>frame.setVisible(true);</code> <br><br>But when run it doesnt come out as expected. <br><div id ="image-container"><img src="/topdownerror.png" width="70%" height="70%" alt="topdownerror"></div> <br>After awhile of troubleshooting I figured out it could be because of a value used in some wad files, a 25565 byte represents null or 0, meaning no wall in that location. I tried to skip over these numbers or interpret them as null but this removes any rendering of the walls at all. <br><br> In the meantime I worked on the character renderer.<br><br><code>WadFile wadFile = new WadFile("src/DOOM1.WAD");<br>
                        Map<String, byte[]> spriteDataMap = new HashMap<>();<br>
                        byte[] paletteData = null;<br>
                        Map<String, String> lumpToSequence = new HashMap<>();<br>
                        lumpToSequence.put("TROOA1", "sequence1");<br>
                        lumpToSequence.put("TROOB1", "sequence1");<br>
                        lumpToSequence.put("TROOC1", "sequence1");<br>
                        lumpToSequence.put("TROOD1", "sequence1");<br>
                        lumpToSequence.put("TROOE1", "sequence2");<br>
                        lumpToSequence.put("TROOF1", "sequence2");<br>
                        lumpToSequence.put("TROOG1", "sequence2");<br>
                      </code><br><br>Added sequences of animations that can be cycled through with a button
                      <br><br><code>nextSequenceButton = new JButton("Next Sequence");<br>
                        <span style="display: inline-block; margin-left: 20px;"></span>nextSequenceButton.addActionListener(e -> {<br>
                        <span style="display: inline-block; margin-left: 40px;"></span>int currentIndex = sequenceNames.indexOf(currentSequenceName);<br>
                        <span style="display: inline-block; margin-left: 40px;"></span>currentSequenceName = sequenceNames.get((currentIndex + 1) % sequenceNames.size());<br>
                        <span style="display: inline-block; margin-left: 40px;"></span>currentSpriteIndex = 0;<br>
                        <span style="display: inline-block; margin-left: 40px;"></span>repaint();<br>
                        <span style="display: inline-block; margin-left: 20px;"></span>});<br>
                        this.add(nextSequenceButton);<br>
                  }</code><br><br><div id ="image-container"><video controls = "false" width="500" autoplay loop><source src="/animationseq.webm" type="video/webm"width="70%" height="70%" alt="animation"></div><br><br>Amazing! but the animations are in reverse, to figure this I updated the SpriteRenderer.java.<br><div id ="image-container"><img src="/spriterenderer.png" width="70%" height="70%" alt="spriterenderer"></div><br><br> The frames seem to be in order so it must be a bug somewhere in the conversion from lumps to image; to fix this for now I just changed the sprite index to play in the opposite direction, changing.<br><br><code>this.timer = new Timer(animationDelay, e -> {<br>
                  <span style="display: inline-block; margin-left: 60px;"></span>currentSpriteIndex = (currentSpriteIndex + 1) % spriteSequences.get(currentSequenceName).size();<br>
                  <span style="display: inline-block; margin-left: 60px;"></span>repaint();<br>
                });<br>
                timer.start();</code><br><br> to this <br><br>
                  <code>this.timer = new Timer(animationDelay, e -> {<br>
                  <span style="display: inline-block; margin-left: 20px;"></span>currentSpriteIndex--;<br>
                  <span style="display: inline-block; margin-left: 20px;"></span>if (currentSpriteIndex < 0) {<br>
                  <span style="display: inline-block; margin-left: 60px;"></span>currentSpriteIndex = spriteSequences.get<br>(currentSequenceName).size() - 1;<br>
                  <span style="display: inline-block; margin-left: 20px;"></span>}<br>
                  <span style="display: inline-block; margin-left: 20px;"></span>repaint();<br>
                });<br>
                timer.start();</code><br><br><div id ="image-container"><video controls = "false" width="500" autoplay loop><source src="/animationseqforward.webm" type="video/webm"width="70%" height="70%" alt="animationforward"></div><br> 
                </p>
              </div>
              <button class="read-more-btn">>Read More</button>
              </div>

            </div>

            <script>

            const readMoreButtons = document.querySelectorAll('.read-more-btn');

readMoreButtons.forEach((button) => {
  button.addEventListener('click', () => {
    const blogPost = button.parentNode;
    const shortContent = blogPost.querySelector('.short-content');
    const fullContent = blogPost.querySelector('.full-content');

    if (fullContent.style.display === 'none' || fullContent.style.display === '') {
      fullContent.style.display = 'block';
      shortContent.style.display = 'none';
      button.textContent = 'Close';
    } else {
      fullContent.style.display = 'none';
      shortContent.style.display = 'block';
      button.textContent = '>Read More';
    }
  });
});

</script>
        
</html>